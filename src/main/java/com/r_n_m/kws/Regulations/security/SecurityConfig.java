package com.r_n_m.kws.Regulations.security;import com.r_n_m.kws.Regulations._enum.Role;import com.r_n_m.kws.Regulations._interface.AccountOps;import com.r_n_m.kws.Regulations.security._jwt.AuthenticationUtil;import com.r_n_m.kws.Regulations.security._jwt.JWTFilter;import jakarta.servlet.http.HttpServletResponse;import lombok.extern.slf4j.Slf4j;import lombok.val;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.web.servlet.FilterRegistrationBean;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.security.authentication.AuthenticationManager;import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;import org.springframework.security.config.annotation.web.builders.HttpSecurity;import org.springframework.security.config.http.SessionCreationPolicy;import org.springframework.security.core.userdetails.UserDetailsService;import org.springframework.security.crypto.argon2.Argon2PasswordEncoder;import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;import org.springframework.security.crypto.password.DelegatingPasswordEncoder;import org.springframework.security.crypto.password.PasswordEncoder;import org.springframework.security.crypto.password.Pbkdf2PasswordEncoder;import org.springframework.security.crypto.scrypt.SCryptPasswordEncoder;import org.springframework.security.web.SecurityFilterChain;import java.util.HashMap;import java.util.Map;/** * @author Puum Core (Mandela Murithi)<br> * <a href = "https://github.com/puumCore">GitHub: Mandela Murithi</a> * @version 1.3 * @since 18/07/2022 */@Configuration@Slf4jpublic class SecurityConfig {    public static final String LOGIN_PATH = "/iam/login";    @SuppressWarnings("SpellCheckingInspection")    public static final String s3cr3t = "zV4U5Kgvjo9A7itVRoJuYDXp6X7uWn";    @Autowired    private UserDetailsService userDetailsService;    @Autowired    private AccountOps accountOps;    @Bean    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {        /*          The paths described in the requestMatchers with asterisks(**) are mapped with what is the controller classes,          so if it does not exist in the controller paths e.g. Login URL,          then you have to explicitly dine its absolute path otherwise you can use the parent path of a controller class.        */        http.csrf().disable();        http.sessionManagement().sessionCreationPolicy(SessionCreationPolicy.ALWAYS);        http.authorizeHttpRequests((authorize) -> authorize.requestMatchers("/iam/**", "/error").permitAll());        //For the paths with asterisks you need to explicitly put the parent path placed in the request mapping of every controller        http.authorizeHttpRequests()                .requestMatchers("/account/**").hasAnyAuthority(Role.ADMIN.getAlias(), Role.PATROL.getAlias(), Role.GATE.getAlias());        http.exceptionHandling().authenticationEntryPoint(                (request, response, authException) -> response.sendError(HttpServletResponse.SC_FORBIDDEN, "Sorry, but you don't have authorized access to interact with this system!")        );        http.addFilterAfter(new JWTFilter(accountOps), AuthenticationUtil.class);        //http.sessionManagement(httpSecuritySessionManagementConfigurer -> httpSecuritySessionManagementConfigurer.maximumSessions(3).maxSessionsPreventsLogin(true));        return http.getOrBuild();    }    @Bean    public FilterRegistrationBean<AuthenticationUtil> authenticationFilter(HttpSecurity http) throws Exception {        val authenticationUtil = new AuthenticationUtil(authenticationManager(http, userDetailsService), accountOps);        authenticationUtil.setFilterProcessesUrl(LOGIN_PATH);        FilterRegistrationBean<AuthenticationUtil> registrationBean = new FilterRegistrationBean<>();        registrationBean.setFilter(authenticationUtil);        return registrationBean;    }    @Bean    public AuthenticationManager authenticationManager(HttpSecurity http, UserDetailsService userDetailService) throws Exception {        return http.getSharedObject(AuthenticationManagerBuilder.class)                .userDetailsService(userDetailService)                .passwordEncoder(passwordEncoder())                .and()                .build();    }    @Bean    public PasswordEncoder passwordEncoder() {        var idForEncode = "bcrypt";        Map<String, PasswordEncoder> encoders = new HashMap<>();        encoders.put("bcrypt", new BCryptPasswordEncoder());        encoders.put("pbkdf2@SpringSecurity_v5_8", Pbkdf2PasswordEncoder.defaultsForSpringSecurity_v5_8());        encoders.put("scrypt@SpringSecurity_v5_8", SCryptPasswordEncoder.defaultsForSpringSecurity_v5_8());        encoders.put("argon2@SpringSecurity_v5_8", Argon2PasswordEncoder.defaultsForSpringSecurity_v5_8());        return new DelegatingPasswordEncoder(idForEncode, encoders);    }}